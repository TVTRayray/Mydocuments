和结构体类似，数组（Array）也是一种复合数据类型，它由一系列相同类型的元素
（Element）组成。例如定义一个由4个整数组成的数组count：
int count[4];

和结构体成员类似，数组count的4个元素的存储空间也是相邻的。结构体的成员可以是基本数
据类型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个
由4个结构体元素组成的数组：
```
struct Complex {
 double x, y;
} a[4];
```
也可以定义一个包含数组成员的结构体：
```c
struct {
 double x, y;
 int count[4];
} s;
```
数组类型的长度应该用一个常量表达式来指定，而且这个常量表达式的值必须是整数类型
的，这一点和case后面跟的常量表达式的要求相同。数组中的元素通过下标（或者叫索
引，Index）来访问。

数组和结构体虽然有很多相似之处，但也有一个显著的不同：数组不能互相赋值。例如这样是
错误的：

```c
int a[5], b[5] = { 4, 3, 2, 1 };
a = b;
```
既然不能互相赋值，也就不能用数组类型作为函数的参数或返回值。如果写出这样的函数定
义：
```cvoid foo(int a[5])
{
 ...
}
```
然后这样调用：
```c
int array[5] = {};
foo(array);
```
编译器也不会报错，但这样写并不是传一个数组类型参数的意思。对于数组类型有一条特殊规
则：数组名做右值使用时，自动转换成指向数组首元素的指针。所以上面的函数调用其实是传
一个指针类型的参数，而不是数组类型的参数。接下来的几章里有的函数需要访问数组，我们
就把数组定义为全局变量给函数访问，等以后我们讲了指针再使用传参的办法。这也解释了为
什么数组类型不能互相赋值，上面提到的a = b这个表达式，a和b都是数组类型的变量，但
是b做右值使用，自动转换成指针类型，而左边仍是数组类型，所以编译器报的错误信息
是error: incompatible types in assignment。

